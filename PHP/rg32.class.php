#!/usr/bin/php
<?php

# Copyright (c) 2015,2020 Sam Trenholme
#
# TERMS
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# This software is provided 'as is' with no guarantees of correctness or
# fitness for purpose.

class rg32 {
	protected $belt;
	protected $mill;
	protected $phase;
	
	protected function init_rg() {
		# RG32 constants
		$this->mill = array();
		$this->belt = array();
	
		# Init mill	
		for($a = 0; $a < 19; $a++) {
			$this->mill[$a] = 0;
		}
	
		# Init belt
		for($a = 0; $a < 3; $a++) {
			$this->belt[$a] = array();
			for($b = 0; $b < 13; $b++) {
				$this->belt[$a][$b] = 0;
			}
		}
	
		# Which word to show on output
		$this->phase = 2;
	}

	protected function millfunction() {
		$A = array(); # Copy of mill

		# This code was generated by tools/make.php.mill.awk
		$A[0] = $this->mill[0]^($this->mill[1]|~$this->mill[2]);
		$tmp = $this->mill[7]^($this->mill[8]|~$this->mill[9]);
		$A[1]=((($tmp >> 1) & 0x7fffffff) | ($tmp << 31)) & 0xffffffff;
		$tmp = $this->mill[14]^($this->mill[15]|~$this->mill[16]);
		$A[2]=((($tmp >> 3) & 0x1fffffff) | ($tmp << 29)) & 0xffffffff;
		$tmp = $this->mill[2]^($this->mill[3]|~$this->mill[4]);
		$A[3]=((($tmp >> 6) & 0x3ffffff) | ($tmp << 26)) & 0xffffffff;
		$tmp = $this->mill[9]^($this->mill[10]|~$this->mill[11]);
		$A[4]=((($tmp >> 10) & 0x3fffff) | ($tmp << 22)) & 0xffffffff;
		$tmp = $this->mill[16]^($this->mill[17]|~$this->mill[18]);
		$A[5]=((($tmp >> 15) & 0x1ffff) | ($tmp << 17)) & 0xffffffff;
		$tmp = $this->mill[4]^($this->mill[5]|~$this->mill[6]);
		$A[6]=((($tmp >> 21) & 0x7ff) | ($tmp << 11)) & 0xffffffff;
		$tmp = $this->mill[11]^($this->mill[12]|~$this->mill[13]);
		$A[7]=((($tmp >> 28) & 0xf) | ($tmp << 4)) & 0xffffffff;
		$tmp = $this->mill[18]^($this->mill[0]|~$this->mill[1]);
		$A[8]=((($tmp >> 4) & 0xfffffff) | ($tmp << 28)) & 0xffffffff;
		$tmp = $this->mill[6]^($this->mill[7]|~$this->mill[8]);
		$A[9]=((($tmp >> 13) & 0x7ffff) | ($tmp << 19)) & 0xffffffff;
		$tmp = $this->mill[13]^($this->mill[14]|~$this->mill[15]);
		$A[10]=((($tmp >> 23) & 0x1ff) | ($tmp << 9)) & 0xffffffff;
		$tmp = $this->mill[1]^($this->mill[2]|~$this->mill[3]);
		$A[11]=((($tmp >> 2) & 0x3fffffff)| ($tmp << 30)) & 0xffffffff;
		$tmp = $this->mill[8]^($this->mill[9]|~$this->mill[10]);
		$A[12]=((($tmp >> 14) & 0x3ffff) | ($tmp << 18)) & 0xffffffff;
		$tmp = $this->mill[15]^($this->mill[16]|~$this->mill[17]);
		$A[13]=((($tmp >> 27) & 0x1f) | ($tmp << 5)) & 0xffffffff;
		$tmp = $this->mill[3]^($this->mill[4]|~$this->mill[5]);
		$A[14]=((($tmp >> 9) & 0x7fffff) | ($tmp << 23)) & 0xffffffff;
		$tmp = $this->mill[10]^($this->mill[11]|~$this->mill[12]);
		$A[15]=((($tmp >> 24) & 0xff) | ($tmp << 8)) & 0xffffffff;
		$tmp = $this->mill[17]^($this->mill[18]|~$this->mill[0]);
		$A[16]=((($tmp >> 8) & 0xffffff) | ($tmp << 24)) & 0xffffffff;
		$tmp = $this->mill[5]^($this->mill[6]|~$this->mill[7]);
		$A[17]=((($tmp >> 25) & 0x7f) | ($tmp << 7)) & 0xffffffff;
		$tmp = $this->mill[12]^($this->mill[13]|~$this->mill[14]);
		$A[18]=((($tmp >> 11) & 0x1fffff) | ($tmp << 21)) & 0xffffffff;
		$this->mill[0] = $A[0]^$A[1]^$A[4]^1;
		$this->mill[1] = $A[1]^$A[2]^$A[5];
		$this->mill[2] = $A[2]^$A[3]^$A[6];
		$this->mill[3] = $A[3]^$A[4]^$A[7];
		$this->mill[4] = $A[4]^$A[5]^$A[8];
		$this->mill[5] = $A[5]^$A[6]^$A[9];
		$this->mill[6] = $A[6]^$A[7]^$A[10];
		$this->mill[7] = $A[7]^$A[8]^$A[11];
		$this->mill[8] = $A[8]^$A[9]^$A[12];
		$this->mill[9] = $A[9]^$A[10]^$A[13];
		$this->mill[10] = $A[10]^$A[11]^$A[14];
		$this->mill[11] = $A[11]^$A[12]^$A[15];
		$this->mill[12] = $A[12]^$A[13]^$A[16];
		$this->mill[13] = $A[13]^$A[14]^$A[17];
		$this->mill[14] = $A[14]^$A[15]^$A[18];
		$this->mill[15] = $A[15]^$A[16]^$A[0];
		$this->mill[16] = $A[16]^$A[17]^$A[1];
		$this->mill[17] = $A[17]^$A[18]^$A[2];
		$this->mill[18] = $A[18]^$A[0]^$A[3];

	}
			
	protected function beltfunction() {
		$beltsave = array();

		# Belt function: Simple rotation (Page 9)
		for($beltrow = 0; $beltrow < 3; $beltrow++) {
			$beltsave[$beltrow] = $this->belt[$beltrow][12];
			for($beltcol = 12; $beltcol > 0; $beltcol--) {
				$this->belt[$beltrow][$beltcol] = 
					$this->belt[$beltrow][$beltcol - 1];	
			}
			$this->belt[$beltrow][$beltcol] = $beltsave[$beltrow];
		}

		# Mill->Belt feedforward (Page 9)
		for($i = 0; $i < 12; $i++) {
			$this->belt[$i % 3][$i + 1] ^= $this->mill[$i + 1];
		}

		# Mill 
		$this->millfunction();

		# Belt->Mill feedforward
		for($i = 0; $i < 3; $i++) {
			$this->mill[13 + $i] ^= $beltsave[$i];
		}

	}

	protected function input_map($in) {
		for(;;) {
			for($a = 0; $a < 3; $a++) {
				$s = 0;
				for($q = 0; $q < 4; $q++) {
					$w = ord($in);
					if(strlen($in) < 1) {
						$w = 1;
					}
					$s |= $w << (8 * $q);
					if(strlen($in) < 1) {	
						$this->belt[$a][0] ^= $s;
						$this->mill[$a + 16] ^= $s;
						for($c = 0; $c < 17; $c++) {
							$this->beltfunction();
						}
						return;
					}
					$in = substr($in, 1);
				}
				$this->belt[$a][0] ^= $s;
				$this->mill[$a + 16] ^= $s;
			}
			$this->beltfunction();
		}	
	}

	public function rg() {
		if($this->phase == 2) {
			$this->phase = 1;
			$this->beltfunction();
		} else {
			$this->phase = 2;
		}
		$i = $this->mill[$this->phase];
		$i = (($i & 0xff) << 24) |
		     (($i & 0xff00) << 8) |
		     (($i & 0xff0000) >> 8) |
		     # Again, PHP32 has right-shift issues
		     (($i >> 24) & 0xff);
		return $i;
	}

	public function __construct($seed) {
		$this->init_rg();
		$this->input_map($seed);
	}

}

class rg32crypt extends rg32 {
	protected $base64;
	public $hash;
	# Allow empty rounds to be quickly and easily run
        protected function runmill($n) {
		for($a = 1;$a < $n; $a++) {
			$this->beltfunction();
		}
	}

	protected function b64() {
		$a = $this->rg();
		$a >>= 24;
		$a &= 0x3f;
		$a = substr($this->base64, $a, 1);
		return $a;		
	}

	public function __construct($password, $salt) {
		$this->init_rg();
		$m = substr($salt, 0, 10) . "+" . $password;
		$this->init_rg();
		$this->input_map($m);
		$this->runmill(32753);
		$this->base64 = 
	    "0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.";
		$this->hash = substr($salt, 0, 10);
		for($a = 0; $a < 22; $a++) {
			$this->hash .= $this->b64();
		}
	}

}
	
	

# This is testing code which I used to make sure this code
# generates correct test vectors.
# rg32crypt interface
#@$in = $argv[1];
#$test = new rg32crypt($in,"~~12345678");
#print $test->hash;
#print "\n";
# RG32 interface
#$test2 = new rg32($in);
#for($a = 0; $a < 8; $a++) {printf("%08x",$test2->rg());}
#print "\n";

?>
